# A class for serializing node trees and the properties of all the nodes in the tree into a single Reference
# Nodes in a node tree will only be saved if the node was saved in a scene already
# Nodes added to the group "ignore_properties" will not have their properties stored
class_name SerialTree
extends Reference


enum {SERIALIZING_NODES, LOADING_HIERARCHIES, LOADING_PROPERTIES}

const DONE_POLLING = 1

# A Dict of NodePaths and the path to a tscn file
var packed_scenes: Dictionary
# A Dict of NodePaths and the properties of the node at that path
var node_properties: Dictionary
# Shows the current stage in polling: SERIALIZING_NODES, LOADING_HIERARCHIES or LOADING_PROPERTIES
var stage: int
# If begin_serial was called, root_node is the owner of the node tree given
# If deserealization was compeleted, root_node is the owner of the deserealized tree
var root_node: Node
# If deserealization was compeleted, root_node_path is the absolute path of root_node
var root_node_path: NodePath

# an Array of nodes from which filenames will be found
var _node_quota: Array
var _index: int


static func get_family(node: Node) -> Array:
	# Returns all the descendents of a node in a single Array
	var children := node.get_children()
	
	for child in children:
		children += get_family(child)
	
	return children


static func place_child(node: Node, path: String, root: Node) -> void:
	# Adds a child to the exact path given, by finding the parent and the name of the node
	var last_idx: int = path.find_last("/")
	var parent := path.left(last_idx)
	node.name = path.right(last_idx)
	root.get_node(parent).add_child(node)


static func get_properties(node: Node) -> Dictionary:
	# if a node or its owner is in the group 'ignore_properties', the properties will not be stored
	if node.is_in_group("ignore_properties"):
		return {}

	elif is_instance_valid(node.owner) and node.owner.is_in_group("ignore_properties"):
		return {}
	
	if node.has_method("_serialize"):
		return node._serialize()
	
	else:
		if node.has_method("_start_serialize"):
			node._start_serialize()
		
		var properties: Dictionary
		# store script variables
		if node.get_script() != null:
			properties = inst2dict(node)
			properties.erase("@subpath")		# useless variables generated by inst2dict
			properties.erase("@path")
		
		properties["groups"] = node.get_groups()
		
		# important builtin node variables
		if node is Spatial or node is Node2D:
			properties["transform"] = node.transform
			
			if node is Node2D:
				properties["z_index"] = node.z_index
				properties["z_as_relative"] = node.z_as_relative
		
		# used to omit some variables from being saved
		if "dont_save" in node:
			for name in node.dont_save:
				properties.erase(name)
	
		return properties


static func set_properties(node: Node, properties: Dictionary) -> void:
	# Sets all the variables defined in properties into node
	for group in properties["groups"]:
		node.add_to_group(group)
	
	for key in properties:
		if key == "groups":
			continue
		node.set(key, properties[key])


func serialize_self() -> Array:
	# Returns all the data needed to recreate a scene
	# This form of data can be stored to disk
	return [packed_scenes, node_properties]


func deserialize_self(serial_data: Array) -> void:
	# Loads all the data needed to recreate a scene
	packed_scenes = serial_data[0]
	node_properties = serial_data[1]


func get_stage() -> int:
	# Returns the number of polls called
	return _index


func get_stage_count() -> int:
	# Returns the number of required poll calls to serialize or deserealize
	if stage == SERIALIZING_NODES:
		return _node_quota.size()
		
	else:
		return _node_quota.size() + node_properties.size()


func begin_serial(node: Node) -> void:
	# Prepares the SerialTree to serialize a node tree
	_node_quota = get_family(node)
	_node_quota.insert(0, node)
	root_node = node
	packed_scenes.clear()
	_index = 0
	stage = SERIALIZING_NODES


func poll_serial() -> int:
	# Serializes the nodes prepared during begin_serial
	if _index == _node_quota.size():
		return DONE_POLLING
	
	var node: Node = _node_quota[_index]
	
	if not node.is_in_group("dont_save"):
		var path: NodePath
		
		if node == root_node:
			path = root_node.get_path()
		else:
			path = root_node.get_path_to(node)
		
		# For a new packed scene to be added, the node must've been instanced from a scene-
		# besides that, if the node doesnt have an owner, it was added dynamically. Thus, it is a unique scene
		# If the node's owner is not null, it means it was already part of another scene. Instancing it again would make multiple copies of the same scene
		if not node.filename.empty() and not is_instance_valid(node.owner):
			packed_scenes[path] = node.filename
		
		var property := get_properties(node)
		if not property.empty():
			node_properties[path] = property
	
	_index += 1
	return OK


func wait_serial() -> int:
	# Calls poll_serial until it is done or an error occured
	# Returns the error code
	var last_error := OK
	while last_error == OK:
		last_error = poll_serial()
	return last_error


func begin_deserial() -> void:
	# Prepares the SerialTree to deserealize the data stored into a node tree
	# 
	_index = 0
	stage = LOADING_HIERARCHIES


func poll_deserial() -> int:
	# Loads the scenes stored in packed_scenes, and applies all the properties stored
	if _index == packed_scenes.size():
		stage = LOADING_PROPERTIES
		
	if _index >= packed_scenes.size():
		var i := _index - packed_scenes.size()
		if i == node_properties.size():
			return DONE_POLLING
		
		var path: NodePath = node_properties.keys()[i]
		var node: Node
		if i == 0:
			node = root_node
		else:
			node = root_node.get_node(path)
		set_properties(node, node_properties[path])
		
	else:
		var path: NodePath = packed_scenes.keys()[_index]
		var node: Node = load(packed_scenes.values()[_index]).instance()
		
		if _index == 0:
			root_node_path = path
			root_node = node
			
		else:
			place_child(node, path, root_node)
	
	_index += 1
	return OK


func wait_deserial() -> int:
	# Calls poll_deserial until it is done or an error occured
	# Returns the error code
	var last_error := OK
	while last_error == OK:
		last_error = poll_deserial()
	return last_error
